<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CubeLearn</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root {
  --accent: #00e5ff;
  --recent-solve: #00ff00;
  --plus2: #ffa500;
  --dnf: #ff0000;
  --bg: #0f1115;
  --panel: rgba(0,0,0,0.65);
  --text: #ffffff;
}

* { box-sizing: border-box; font-family:"Segoe UI",sans-serif; }
body { margin:0; background:var(--bg); color:var(--text); min-height:100vh; background-size:cover; background-position:center; overflow:hidden; }

.overlay { background: rgba(0,0,0,0.6); min-height:100vh; padding:20px; position:relative; }

h1 { text-align:center; margin-bottom:10px; cursor:move; }

.draggable { position:absolute; cursor:grab; background:var(--panel); border-radius:8px; transition: background 0.2s; }

.resize-handle { width:12px; height:12px; background:yellow; position:absolute; right:2px; bottom:2px; cursor:se-resize; display:none; border-radius:2px; }

.scramble { text-align:center; font-size:1.4rem; margin:10px; letter-spacing:2px; max-width:400px; }

.timer { font-size:5rem; text-align:center; margin:15px 0; color: var(--accent); transition: color 0.2s; }

.controls, .mode, .background-controls, .color-customization { display:flex; justify-content:center; gap:10px; margin-bottom:10px; flex-wrap:wrap; }

button { background: var(--panel); color:white; border:1px solid var(--accent); padding:10px 18px; font-size:1rem; cursor:pointer; border-radius:8px; transition:0.2s; }
button:hover { background: var(--accent); color:black; }

input, select { padding:8px; font-size:1rem; border-radius:6px; border:none; text-align:center; }

.right-panel { display:flex; flex-direction:column; max-width:300px; }

.stats, .solves { background: var(--panel); padding:10px; border-radius:12px; margin-bottom:10px; max-height:300px; overflow-y:auto; }

.solve { display:flex; justify-content:flex-start; gap:10px; border-bottom:1px solid #333; padding:6px 0; }
.solve span { min-width:50px; text-align:left; }

#trendChart { max-width:300px; width:100%; margin-bottom:10px; background:var(--panel); padding:10px; border-radius:12px; }

.session-select { background: var(--panel); color:white; border:1px solid var(--accent); padding:5px; border-radius:6px; }

.footer { display:flex; justify-content:space-between; padding:5px 10px; font-size:0.9rem; color:#aaa; position:fixed; bottom:0; left:0; right:0; pointer-events:none; }

.edit-mode-toggle { position:fixed; top:10px; right:10px; z-index:1000; }
</style>
</head>
<body>
<div class="overlay">

<h1 id="title">CubeLearn</h1>

<button class="edit-mode-toggle" id="editToggle">Edit Mode: OFF</button>

<!-- Mode & Session -->
<div class="mode draggable" id="modePanel">
  <select id="sessionSelect" class="session-select"></select>
  <select id="puzzleTypeSelect">
    <option value="3x3">3x3</option>
    <option value="2x2">2x2</option>
    <option value="4x4">4x4</option>
    <option value="megaminx">Megaminx</option>
    <option value="skewb">Skewb</option>
  </select>
  <button onclick="toggleMode()"><span id="modeBtn">Timer Mode</span></button>
  <div class="resize-handle"></div>
</div>

<!-- Color customization -->
<div class="color-customization draggable" id="colorPanel">
  <label>Timer Color: <input type="color" id="timerColor" value="#00e5ff"></label>
  <label>Recent Solve: <input type="color" id="recentColor" value="#00ff00"></label>
  <label>+2 Solve: <input type="color" id="plus2Color" value="#ffa500"></label>
  <label>DNF Solve: <input type="color" id="dnfColor" value="#ff0000"></label>
  <label>Tile Style:
    <select id="tileStyleSelect">
      <option value="default">Default</option>
      <option value="solid">Solid Color</option>
      <option value="custom">Custom Colors</option>
    </select>
  </label>
  <label id="solidColorLabel" style="display:none;">
    Solid Color: <input type="color" id="solidTileColor" value="#333333">
  </label>
  <div class="resize-handle"></div>
</div>

<!-- Left Panel -->
<div class="left-panel draggable" id="leftPanel">
  <div class="scramble" id="scramble"></div>
  <div class="timer" id="timer">0.00</div>
  <div class="controls" id="manualControls" style="display:none;">
    <input id="manualInput" placeholder="1234" autocomplete="off">
  </div>
  <div class="controls">
    <button onclick="addPenalty()">+2</button>
    <button onclick="setDNF()">DNF</button>
    <button onclick="resetSession()">Reset Current</button>
    <button onclick="saveAll()">Save All</button>
  </div>
  <div class="background-controls">
    <input type="file" accept="image/*" onchange="setBackground(event)">
    <button onclick="clearBackground()">Reset BG</button>
  </div>
  <div class="resize-handle"></div>
</div>

<!-- Right Panel -->
<div class="right-panel draggable" id="rightPanel">
  <div class="stats" id="statsPanel">
    <div>Solves: <span id="count">0</span></div>
    <div>ao5: <span id="ao5">-</span></div>
    <div>ao12: <span id="ao12">-</span></div>
    <div>Best: <span id="best">-</span></div>
    <div>Worst: <span id="worst">-</span></div>
  </div>
  <div class="solves" id="solves"></div>
  <canvas id="trendChart"></canvas>
  <div class="resize-handle"></div>
</div>

</div>

<div class="footer">
  <div>v1.2.1</div>
</div>

<script>
/* ---------- STATE ---------- */
let timerMode=true, running=false, readyToStart=false, startTime=0, interval;
let sessions={}, currentSession="1";
let solveList=[], currentIndex=-1;
let backgroundData=null;
let editMode=false;

/* ---------- DOM ---------- */
const timerEl=document.getElementById("timer");
const scrambleEl=document.getElementById("scramble");
const solvesDiv=document.getElementById("solves");
const countEl=document.getElementById("count");
const ao5El=document.getElementById("ao5");
const ao12El=document.getElementById("ao12");
const bestEl=document.getElementById("best");
const worstEl=document.getElementById("worst");
const manualControls=document.getElementById("manualControls");
const manualInput=document.getElementById("manualInput");
const sessionSelect=document.getElementById("sessionSelect");
const puzzleTypeSelect=document.getElementById("puzzleTypeSelect");
const modeBtn=document.getElementById("modeBtn");

const tileStyleSelect = document.getElementById("tileStyleSelect");
const solidColorInput = document.getElementById("solidTileColor");
const solidColorLabel = document.getElementById("solidColorLabel");
const panels = document.querySelectorAll(".draggable");

/* ---------- TREND CHART ---------- */
const ctx=document.getElementById('trendChart').getContext('2d');
let chart=new Chart(ctx,{
  type:'line',
  data:{labels:[],datasets:[{label:'Time (s)',data:[],borderColor:'cyan',backgroundColor:'transparent'}]},
  options:{scales:{y:{beginAtZero:true}}}
});

/* ---------- SCRAMBLE ---------- */
const movesDict={"2x2":["R","L","U","D","F","B"],"3x3":["R","L","U","D","F","B"],"4x4":["R","L","U","D","F","B","Rw","Lw","Uw","Dw","Fw","Bw"],"megaminx":["R","D","U","L","B"],"skewb":["R","L","U","B"]};
const mods=["","'","2"];
function newScramble(){
  let moves=movesDict[puzzleTypeSelect.value]||movesDict["3x3"];
  let s=[], last="";
  while(s.length<20){ let m=moves[Math.floor(Math.random()*moves.length)]; if(m===last) continue; last=m; s.push(m+mods[Math.floor(Math.random()*3)]);}
  scrambleEl.textContent=s.join(" ");
}
newScramble();

/* ---------- FORMAT ---------- */
function format(ms){ return ms.toFixed(2); }

/* ---------- TIMER ---------- */
document.addEventListener("keydown", e=>{
  if(timerMode && e.code==="Space"){
    e.preventDefault();
    if(!running && !readyToStart){ readyToStart=true; timerEl.style.color="yellow"; } 
    else if(running){ stopTimer(); }
  }
});
document.addEventListener("keyup", e=>{
  if(timerMode && e.code==="Space" && readyToStart){
    readyToStart=false; 
    timerEl.style.color=getComputedStyle(document.documentElement).getPropertyValue("--accent");
    startTimer();
  }
});
function startTimer(){ running=true; startTime=performance.now(); interval=setInterval(()=>{ timerEl.textContent=format((performance.now()-startTime)/1000); },10); }
function stopTimer(){ running=false; clearInterval(interval); addSolve((performance.now()-startTime)/1000); }

/* ---------- MANUAL INPUT ---------- */
manualInput.addEventListener("keydown", e => {
  if(e.key === "Enter"){
    let v = parseInt(manualInput.value);
    if(!isNaN(v)){ addSolve(v/100); manualInput.value = ""; }
  }
});

/* ---------- SOLVE MANAGEMENT ---------- */
function addSolve(time){ solveList.push({time,penalty:0,dnf:false}); currentIndex=solveList.length-1; if(timerMode) newScramble(); updateUI(); }
function addPenalty(){ if(currentIndex>=0 && !solveList[currentIndex].dnf){ solveList[currentIndex].penalty+=0.02; updateUI(); } }
function setDNF(){ if(currentIndex>=0){ solveList[currentIndex].dnf=true; updateUI(); } }

/* ---------- STATISTICS & UI ---------- */
function calcAO(n){
  let valid=solveList.filter(s=>!s.dnf);
  if(valid.length<n) return "-";
  let last=valid.slice(-n).map(s=>s.time+s.penalty).sort((a,b)=>a-b);
  last.shift(); last.pop();
  return format(last.reduce((a,b)=>a+b,0)/(n-2));
}
function updateUI(){
  solvesDiv.innerHTML = "";
  [...solveList].reverse().forEach((s,i)=>{
    let idx = solveList.length-i;
    let t;
    if(s.dnf){ t = "DNF"; } 
    else { let total = s.time + s.penalty; t = format(total); if(s.penalty) t += " +"; }
    let d = document.createElement("div");
    d.className = "solve";
    let color = "var(--text)";
    if(idx === solveList.length) color = "var(--recent-solve)";
    if(s.dnf) color = "var(--dnf)";
    if(s.penalty && !s.dnf) color = "var(--plus2)";
    d.innerHTML = `<span>#${idx}</span><span style="color:${color}">${t}</span>`;
    solvesDiv.appendChild(d);
  });
  countEl.textContent = solveList.length;
  ao5El.textContent = calcAO(5);
  ao12El.textContent = calcAO(12);
  let validTimes = solveList.filter(s=>!s.dnf).map(s=>s.time+s.penalty);
  bestEl.textContent = validTimes.length ? format(Math.min(...validTimes)) : "-";
  worstEl.textContent = validTimes.length ? format(Math.max(...validTimes)) : "-";
  chart.data.labels = solveList.map((_,i)=>i+1);
  chart.data.datasets[0].data = solveList.map(s=>s.dnf?null:(s.time+s.penalty));
  chart.update();
  updateTileStyle();
}

/* ---------- MODE TOGGLE ---------- */
function toggleMode(){ timerMode=!timerMode; manualControls.style.display=timerMode?"none":"flex"; modeBtn.textContent=timerMode?"Timer Mode":"Manual Mode"; }

/* ---------- BACKGROUND ---------- */
function setBackground(e){ const file=e.target.files[0]; if(!file) return; const reader=new FileReader(); reader.onload=()=>{ backgroundData=reader.result; document.body.style.backgroundImage=`url(${backgroundData})`; }; reader.readAsDataURL(file); }
function clearBackground(){ backgroundData=null; document.body.style.backgroundImage=""; }

/* ---------- SESSIONS ---------- */
function saveAllSessions(){ sessions[currentSession]=solveList; localStorage.setItem("cubeSessions",JSON.stringify(sessions)); }
function loadAllSessions(){ sessions=JSON.parse(localStorage.getItem("cubeSessions"))||{}; for(let i=1;i<=15;i++){ if(!sessions[i]) sessions[i]=[]; } updateSessionSelect(); }
function updateSessionSelect(){ sessionSelect.innerHTML=""; for(let i=1;i<=15;i++){ let o=document.createElement("option"); o.value=i; o.text="Session "+i; sessionSelect.appendChild(o); } sessionSelect.value=currentSession; }
function loadSession(){ solveList=sessions[currentSession]||[]; currentIndex=solveList.length-1; updateUI(); }
function resetSession(){ if(confirm("Reset current session?")){ solveList=[]; currentIndex=-1; updateUI(); } }

/* ---------- SAVE ALL INCLUDING POSITIONS & SIZE ---------- */
function saveAll(){
  sessions[currentSession]=solveList;
  const layout = {};
  document.querySelectorAll(".draggable").forEach(el=>{
    layout[el.id] = {top: el.style.top, left: el.style.left, width: el.style.width, height: el.style.height};
  });
  const data={sessions, background: backgroundData, layout};
  localStorage.setItem("cubeAllData", JSON.stringify(data));
  alert("All sessions, background, layout saved!");
}

function loadAll(){
  const data=localStorage.getItem("cubeAllData");
  if(!data) return;
  const parsed=JSON.parse(data);
  sessions=parsed.sessions||{};
  backgroundData=parsed.background||null;
  if(backgroundData) document.body.style.backgroundImage=`url(${backgroundData})`;
  
  if(parsed.layout){
    Object.entries(parsed.layout).forEach(([id,pos])=>{
      const el = document.getElementById(id);
      if(el){
        el.style.top=pos.top; el.style.left=pos.left;
        el.style.width=pos.width || "";
        el.style.height=pos.height || "";
      }
    });
  } else {
    document.getElementById("modePanel").style.top="50px"; document.getElementById("modePanel").style.left="50px";
    document.getElementById("colorPanel").style.top="50px"; document.getElementById("colorPanel").style.right="50px";
    document.getElementById("leftPanel").style.top="150px"; document.getElementById("leftPanel").style.left="50px";
    document.getElementById("rightPanel").style.top="150px"; document.getElementById("rightPanel").style.right="50px";
  }
}

/* ---------- COLOR PICKERS ---------- */
document.getElementById("timerColor").addEventListener("input", e => { document.documentElement.style.setProperty("--accent", e.target.value); timerEl.style.color=e.target.value; updateUI(); });
document.getElementById("recentColor").addEventListener("input", e => { document.documentElement.style.setProperty("--recent-solve", e.target.value); updateUI(); });
document.getElementById("plus2Color").addEventListener("input", e => { document.documentElement.style.setProperty("--plus2", e.target.value); updateUI(); });
document.getElementById("dnfColor").addEventListener("input", e => { document.documentElement.style.setProperty("--dnf", e.target.value); updateUI(); });

/* ---------- SESSION & PUZZLE ---------- */
sessionSelect.addEventListener("change",()=>{ currentSession=sessionSelect.value; loadSession(); });
puzzleTypeSelect.addEventListener("change",()=>{ newScramble(); });

/* ---------- EDIT MODE DRAG & RESIZE ---------- */
const draggables = document.querySelectorAll(".draggable");
let offsetX, offsetY, draggingEl=null;
let resizingEl=null, startWidth, startHeight, startX, startY;

document.getElementById("editToggle").addEventListener("click", ()=>{
  editMode=!editMode;
  document.getElementById("editToggle").textContent = `Edit Mode: ${editMode?"ON":"OFF"}`;
  draggables.forEach(el => el.querySelector(".resize-handle").style.display = editMode ? "block" : "none");
  draggables.forEach(el => el.style.border = editMode ? "1px dashed yellow" : "none");
});

// Drag
draggables.forEach(el=>{
  el.addEventListener("mousedown", e=>{
    if(!editMode) return;
    if(e.target.classList.contains("resize-handle")) return;
    draggingEl=el;
    offsetX=e.offsetX; offsetY=e.offsetY;
  });
});
document.addEventListener("mousemove", e=>{
  if(draggingEl){
    draggingEl.style.left=(e.clientX-offsetX)+"px";
    draggingEl.style.top=(e.clientY-offsetY)+"px";
  }
  if(resizingEl){
    resizingEl.style.width=(startWidth + e.clientX - startX)+"px";
    resizingEl.style.height=(startHeight + e.clientY - startY)+"px";
  }
});
document.addEventListener("mouseup", e=>{ draggingEl=null; resizingEl=null; });

// Resize
draggables.forEach(el=>{
  const handle=el.querySelector(".resize-handle");
  handle.addEventListener("mousedown", e=>{
    if(!editMode) return;
    resizingEl=el;
    startWidth=el.offsetWidth; startHeight=el.offsetHeight;
    startX=e.clientX; startY=e.clientY;
    e.stopPropagation();
  });
});

/* ---------- TILE STYLE SWITCHER ---------- */
function updateTileStyle() {
  const style = tileStyleSelect.value;
  if(style === "default") {
    panels.forEach(p => p.style.background = "");
    solidColorLabel.style.display = "none";
  } else if(style === "solid") {
    panels.forEach(p => p.style.background = solidColorInput.value);
    solidColorLabel.style.display = "inline-block";
  } else if(style === "custom") {
    panels.forEach(p => {
      if(p.dataset.customColor) p.style.background = p.dataset.customColor;
      else p.style.background = "";
    });
    solidColorLabel.style.display = "none";
  }
}
tileStyleSelect.addEventListener("change", updateTileStyle);
solidColorInput.addEventListener("input", updateTileStyle);

// Double-click for custom colors
panels.forEach(p=>{
  p.addEventListener("dblclick", e=>{
    if(tileStyleSelect.value!=="custom") return;
    const color = prompt("Enter hex color for this tile:", p.dataset.customColor||"#555555");
    if(color){ p.dataset.customColor=color; p.style.background=color; }
  });
});

/* ---------- INIT ---------- */
loadAll();
loadAllSessions();
loadSession();
updateUI();
</script>
</body>
</html>


